<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="theme-color" content="#0d1117">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="mobile-web-app-capable" content="yes">
<link rel="icon" type="image/png" sizes="32x32" href="../icons/favicon.png">
<link rel="apple-touch-icon" sizes="192x192" href="../icons/icon-192.png">
<link rel="manifest" href="hexcast-manifest.json">
<title>hexcast â€” stream camera</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { touch-action: manipulation; }
    body { background: #0d1117; color: #e6edf3; font-family: -apple-system, 'SF Pro', system-ui, sans-serif; min-height: 100dvh; display: flex; flex-direction: column; overflow: hidden; }

    /* â”€â”€ Rainbow bar â”€â”€ */
    .rainbow { display: flex; height: 3px; width: 100%; flex-shrink: 0; }
    .rainbow span { flex: 1; }

    /* â”€â”€ Top bar â”€â”€ */
    .topbar { display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: #161b22; border-bottom: 1px solid #21262d; flex-shrink: 0; }
    .topbar-logo { width: 20px; height: 20px; border-radius: 5px; display: flex; align-items: center; justify-content: center; font-size: 12px; background: linear-gradient(135deg, #58a6ff 0%, #bc8cff 100%); color: #fff; font-weight: 700; }
    .topbar-title { font-size: .8125rem; font-weight: 600; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .topbar-title .sub { color: #8b949e; font-weight: 400; }

    /* â”€â”€ Status pill â”€â”€ */
    .status-pill { font-size: .5625rem; font-weight: 600; padding: 3px 8px; border-radius: 10px; text-transform: uppercase; letter-spacing: .3px; white-space: nowrap; }
    .status-pill.off { background: #30363d; color: #8b949e; }
    .status-pill.connecting { background: #e3b341; color: #0d1117; }
    .status-pill.live { background: #238636; color: #fff; animation: pulse-bg 2s infinite; }
    .status-pill.error { background: #da3633; color: #fff; }
    @keyframes pulse-bg { 0%,100% { opacity: 1; } 50% { opacity: .75; } }

    /* â”€â”€ Control strip (swap + quality + filter) â”€â”€ */
    .ctrl-strip { display: flex; gap: 6px; padding: 6px 12px; background: #0d1117; flex-shrink: 0; overflow-x: auto; -webkit-overflow-scrolling: touch; }
    .ctrl-btn { background: #21262d; border: 1px solid #30363d; color: #c9d1d9; padding: 5px 10px; border-radius: 6px; font-size: .6875rem; font-weight: 600; cursor: pointer; white-space: nowrap; display: flex; align-items: center; gap: 4px; }
    .ctrl-btn:active { transform: scale(.96); }
    .ctrl-btn.active { background: #1f6feb; border-color: #388bfd; color: #fff; }
    .ctrl-btn.swap { background: #1f6feb22; border-color: #1f6feb; color: #58a6ff; }
    .ctrl-btn.swap:active { background: #1f6feb; color: #fff; }

    /* â”€â”€ Video area â”€â”€ */
    .video-area { flex: 1; position: relative; min-height: 0; background: #000; overflow: hidden; }
    .video-area video { width: 100%; height: 100%; object-fit: cover; display: block; }
    .video-area canvas#filter-canvas { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; pointer-events: none; display: none; }
    .video-area canvas#hidden-canvas { display: none; }

    /* â”€â”€ Overlay badges â”€â”€ */
    .badge-tl { position: absolute; top: 8px; left: 8px; }
    .badge-tr { position: absolute; top: 8px; right: 8px; }
    .badge { background: rgba(0,0,0,.65); color: #c9d1d9; font-size: .5625rem; padding: 3px 8px; border-radius: 4px; font-family: 'SF Mono', ui-monospace, monospace; backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); }
    .badge.live { color: #3fb950; }
    .badge.live::before { content: ''; display: inline-block; width: 5px; height: 5px; background: #3fb950; border-radius: 50%; margin-right: 4px; animation: blink 1.2s infinite; }
    @keyframes blink { 0%,100% { opacity: 1; } 50% { opacity: .3; } }

    /* â”€â”€ Filter label (center tap indicator) â”€â”€ */
    .filter-label { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,.7); color: #fff; font-size: .75rem; font-weight: 600; padding: 4px 14px; border-radius: 12px; pointer-events: none; opacity: 0; transition: opacity .25s; }
    .filter-label.show { opacity: 1; }

    /* â”€â”€ Stats strip â”€â”€ */
    .stats-strip { display: flex; gap: 12px; padding: 6px 12px; background: #161b22; border-top: 1px solid #21262d; font-size: .625rem; font-family: 'SF Mono', ui-monospace, monospace; color: #8b949e; flex-shrink: 0; flex-wrap: wrap; align-items: center; }
    .stats-strip .val { color: #58a6ff; }
    .stats-strip .sep { color: #30363d; }

    /* â”€â”€ Connect bar â”€â”€ */
    .connect-bar { display: flex; gap: 6px; padding: 8px 12px; background: #0d1117; border-top: 1px solid #21262d; flex-shrink: 0; }
    .connect-bar input { flex: 1; background: #161b22; border: 1px solid #30363d; border-radius: 6px; padding: 8px 10px; color: #e6edf3; font-size: .8125rem; font-family: 'SF Mono', ui-monospace, monospace; }
    .connect-bar input:focus { outline: none; border-color: #58a6ff; box-shadow: 0 0 0 2px #1f6feb33; }
    .send-btn { background: #238636; border: none; color: #fff; padding: 8px 16px; border-radius: 6px; font-size: .8125rem; font-weight: 700; cursor: pointer; min-width: 56px; }
    .send-btn:active { transform: scale(.97); }
    .send-btn.stop { background: #da3633; }

    /* â”€â”€ Chat input â”€â”€ */
    .chat-bar { display: flex; gap: 6px; padding: 6px 12px; background: #161b22; border-top: 1px solid #21262d; flex-shrink: 0; }
    .chat-bar input { flex: 1; background: #0d1117; border: 1px solid #30363d; border-radius: 6px; padding: 7px 10px; color: #e6edf3; font-size: .75rem; }
    .chat-bar input:focus { outline: none; border-color: #bc8cff; }
    .chat-bar input::placeholder { color: #484f58; }
    .chat-send { background: #30363d; border: 1px solid #484f58; color: #c9d1d9; padding: 7px 12px; border-radius: 6px; font-size: .6875rem; font-weight: 600; cursor: pointer; }
    .chat-send:active { background: #484f58; }

    /* â”€â”€ Bottom rainbow â”€â”€ */
    .rainbow-bottom { display: flex; height: 2px; width: 100%; flex-shrink: 0; }
    .rainbow-bottom span { flex: 1; }

    /* â”€â”€ Safe-area padding â”€â”€ */
    @supports (padding: env(safe-area-inset-bottom)) {
        .chat-bar { padding-bottom: calc(6px + env(safe-area-inset-bottom)); }
    }
</style>
</head>
<body>

<!-- â”â”â” Top rainbow â”â”â” -->
<div class="rainbow"><span style="background:#ff3838"></span><span style="background:#ff8c38"></span><span style="background:#ffe138"></span><span style="background:#3fb950"></span><span style="background:#38a5ff"></span><span style="background:#bc8cff"></span></div>

<!-- â”â”â” Top bar â”â”â” -->
<div class="topbar">
    <div class="topbar-logo">â¬¡</div>
    <div class="topbar-title">hexcast <span class="sub">send</span></div>
    <span class="status-pill off" id="status-pill">disconnected</span>
</div>

<!-- â”â”â” Control strip â”â”â” -->
<div class="ctrl-strip">
    <button class="ctrl-btn swap" id="btn-swap" onclick="swapCamera()">â†º Swap</button>
    <button class="ctrl-btn" id="btn-quality" onclick="cycleQuality()">â—‰ med</button>
    <button class="ctrl-btn" id="btn-filter" onclick="cycleFilter()">â— none</button>
    <button class="ctrl-btn" id="btn-torch" onclick="toggleTorch()">ğŸ”¦ Torch</button>
    <button class="ctrl-btn" id="btn-snapshot" onclick="takeSnapshot()">ğŸ“¸</button>
</div>

<!-- â”â”â” Video feed â”â”â” -->
<div class="video-area" id="video-area">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="filter-canvas"></canvas>
    <canvas id="hidden-canvas"></canvas>
    <div class="badge-tl"><span class="badge" id="badge">camera off</span></div>
    <div class="badge-tr"><span class="badge" id="badge-filter"></span></div>
    <div class="filter-label" id="filter-label">Normal</div>
</div>

<!-- â”â”â” Stats strip â”â”â” -->
<div class="stats-strip">
    <span>FPS <span class="val" id="s-fps">0</span></span>
    <span class="sep">Â·</span>
    <span>Frames <span class="val" id="s-frames">0</span></span>
    <span class="sep">Â·</span>
    <span><span class="val" id="s-size">0 KB</span>/f</span>
    <span class="sep">Â·</span>
    <span>Cam <span class="val" id="s-cam">â€”</span></span>
    <span style="flex:1"></span>
    <span>Lat <span class="val" id="s-lat">â€”</span></span>
</div>

<!-- â”â”â” Connect bar â”â”â” -->
<div class="connect-bar">
    <input type="text" id="host-input" placeholder="IP:port  (e.g. 192.168.1.42:9876)" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" inputmode="url">
    <button class="send-btn" id="connect-btn" onclick="toggleStream()">Send</button>
</div>

<!-- â”â”â” Chat bar â”â”â” -->
<div class="chat-bar">
    <input type="text" id="chat-input" placeholder="message to terminalâ€¦" autocomplete="off" autocorrect="off">
    <button class="chat-send" onclick="sendChat()">Send</button>
</div>

<!-- â”â”â” Bottom rainbow â”â”â” -->
<div class="rainbow-bottom"><span style="background:#ff3838"></span><span style="background:#ff8c38"></span><span style="background:#ffe138"></span><span style="background:#3fb950"></span><span style="background:#38a5ff"></span><span style="background:#bc8cff"></span></div>

<script>
'use strict';

const video = document.getElementById('video');
const filterCanvas = document.getElementById('filter-canvas');
const hiddenCanvas = document.getElementById('hidden-canvas');
const fCtx = filterCanvas.getContext('2d');
const hCtx = hiddenCanvas.getContext('2d');
const hostInput = document.getElementById('host-input');
const badge = document.getElementById('badge');
const badgeFilter = document.getElementById('badge-filter');
const statusPill = document.getElementById('status-pill');
const connectBtn = document.getElementById('connect-btn');
const filterLabel = document.getElementById('filter-label');
const chatInput = document.getElementById('chat-input');

let ws = null, stream = null, animId = null;
let frameCount = 0, lastFpsTime = 0, lastFpsCount = 0;
let facingMode = 'environment'; // default: back camera for streaming
let torchOn = false;

// â”€â”€ Quality presets â”€â”€
const qualities = [
    { label: 'low', q: 0.3, w: 240, h: 180 },
    { label: 'med', q: 0.5, w: 480, h: 360 },
    { label: 'high', q: 0.7, w: 640, h: 480 },
    { label: 'max', q: 0.85, w: 1280, h: 720 },
];
let qualityIdx = 1;
let quality = qualities[qualityIdx].q;

// â”€â”€ Filter presets â”€â”€
const filters = [
    { name: 'none', label: 'Normal', fn: null },
    { name: 'thermal', label: 'Thermal', fn: applyThermal },
    { name: 'gray', label: 'Grayscale', fn: applyGray },
    { name: 'fax', label: 'Fax B/W', fn: applyFax },
    { name: 'signal', label: 'Signal', fn: applySignal },
    { name: 'edge', label: 'Edge Detect', fn: applyEdge },
    { name: 'invert', label: 'Invert', fn: applyInvert },
    { name: 'cyber', label: 'Cyberpunk', fn: applyCyber },
];
let filterIdx = 0;

// Auto-fill from URL hash
if (location.hash) hostInput.value = location.hash.slice(1);

// â”€â”€ Camera â”€â”€
async function startCamera() {
    if (stream) stream.getTracks().forEach(t => t.stop());
    const q = qualities[qualityIdx];
    try {
        stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode, width: { ideal: q.w }, height: { ideal: q.h } },
            audio: false
        });
        video.srcObject = stream;
        await video.play();
        const track = stream.getVideoTracks()[0];
        const s = track.getSettings();
        document.getElementById('s-cam').textContent = `${facingMode === 'user' ? 'front' : 'back'} ${s.width||'?'}Ã—${s.height||'?'}`;
        badge.textContent = facingMode === 'user' ? 'front' : 'back';
        badge.className = 'badge';
        updateFilterCanvas();
    } catch (e) {
        badge.textContent = 'camera: ' + e.message;
    }
}

function swapCamera() {
    facingMode = facingMode === 'user' ? 'environment' : 'user';
    torchOn = false;
    document.getElementById('btn-torch').classList.remove('active');
    startCamera();
}

function cycleQuality() {
    qualityIdx = (qualityIdx + 1) % qualities.length;
    quality = qualities[qualityIdx].q;
    document.getElementById('btn-quality').textContent = 'â—‰ ' + qualities[qualityIdx].label;
    if (stream) startCamera();
}

function cycleFilter() {
    filterIdx = (filterIdx + 1) % filters.length;
    const f = filters[filterIdx];
    document.getElementById('btn-filter').textContent = 'â— ' + f.name;
    badgeFilter.textContent = f.name === 'none' ? '' : f.name;
    // Show label briefly
    filterLabel.textContent = f.label;
    filterLabel.classList.add('show');
    setTimeout(() => filterLabel.classList.remove('show'), 1200);
    updateFilterCanvas();
}

function updateFilterCanvas() {
    const f = filters[filterIdx];
    filterCanvas.style.display = f.fn ? 'block' : 'none';
}

function toggleTorch() {
    if (!stream) return;
    const track = stream.getVideoTracks()[0];
    if (!track) return;
    torchOn = !torchOn;
    try { track.applyConstraints({ advanced: [{ torch: torchOn }] }); } catch(e) {}
    document.getElementById('btn-torch').classList.toggle('active', torchOn);
}

function takeSnapshot() {
    const q = qualities[qualityIdx];
    hiddenCanvas.width = q.w; hiddenCanvas.height = q.h;
    hCtx.drawImage(video, 0, 0, q.w, q.h);
    if (filters[filterIdx].fn) filters[filterIdx].fn(hCtx, q.w, q.h);
    const a = document.createElement('a');
    a.href = hiddenCanvas.toDataURL('image/png');
    a.download = 'hexcast-' + Date.now() + '.png';
    a.click();
}

// â”€â”€ Tap on video to cycle filter â”€â”€
document.getElementById('video-area').addEventListener('click', e => {
    if (e.target.closest('button') || e.target.closest('input')) return;
    cycleFilter();
});

// â”€â”€ Filter functions â”€â”€
function applyThermal(ctx, w, h) {
    const img = ctx.getImageData(0, 0, w, h), d = img.data;
    for (let i = 0; i < d.length; i += 4) {
        const lum = (d[i] * 0.299 + d[i+1] * 0.587 + d[i+2] * 0.114) / 255;
        if (lum < 0.25) { d[i] = 0; d[i+1] = Math.round(lum*4*255); d[i+2] = 255; }
        else if (lum < 0.5) { d[i] = 0; d[i+1] = 255; d[i+2] = Math.round((1-(lum-0.25)*4)*255); }
        else if (lum < 0.75) { d[i] = Math.round((lum-0.5)*4*255); d[i+1] = 255; d[i+2] = 0; }
        else { d[i] = 255; d[i+1] = Math.round((1-(lum-0.75)*4)*255); d[i+2] = 0; }
    }
    ctx.putImageData(img, 0, 0);
}

function applyGray(ctx, w, h) {
    const img = ctx.getImageData(0, 0, w, h), d = img.data;
    for (let i = 0; i < d.length; i += 4) {
        const g = d[i] * 0.299 + d[i+1] * 0.587 + d[i+2] * 0.114;
        d[i] = d[i+1] = d[i+2] = g;
    }
    ctx.putImageData(img, 0, 0);
}

function applyFax(ctx, w, h) {
    const img = ctx.getImageData(0, 0, w, h), d = img.data;
    for (let i = 0; i < d.length; i += 4) {
        const g = d[i] * 0.299 + d[i+1] * 0.587 + d[i+2] * 0.114;
        const v = g > 128 ? 255 : 0;
        d[i] = d[i+1] = d[i+2] = v;
    }
    ctx.putImageData(img, 0, 0);
}

function applySignal(ctx, w, h) {
    const img = ctx.getImageData(0, 0, w, h), d = img.data;
    for (let i = 0; i < d.length; i += 4) {
        const g = d[i] * 0.299 + d[i+1] * 0.587 + d[i+2] * 0.114;
        d[i] = 0; d[i+1] = Math.round(g * 0.95); d[i+2] = Math.round(g * 0.2);
    }
    ctx.putImageData(img, 0, 0);
}

function applyEdge(ctx, w, h) {
    const src = ctx.getImageData(0, 0, w, h), s = src.data;
    const out = ctx.createImageData(w, h), o = out.data;
    for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
            const idx = (y * w + x) * 4;
            const tl = s[((y-1)*w+x-1)*4], t = s[((y-1)*w+x)*4], tr = s[((y-1)*w+x+1)*4];
            const bl = s[((y+1)*w+x-1)*4], b = s[((y+1)*w+x)*4], br = s[((y+1)*w+x+1)*4];
            const l = s[(y*w+x-1)*4], r = s[(y*w+x+1)*4];
            const gx = -tl + tr - 2*l + 2*r - bl + br;
            const gy = -tl - 2*t - tr + bl + 2*b + br;
            const mag = Math.min(255, Math.sqrt(gx*gx + gy*gy));
            o[idx] = mag * 0.4; o[idx+1] = mag * 0.8; o[idx+2] = mag; o[idx+3] = 255;
        }
    }
    ctx.putImageData(out, 0, 0);
}

function applyInvert(ctx, w, h) {
    const img = ctx.getImageData(0, 0, w, h), d = img.data;
    for (let i = 0; i < d.length; i += 4) { d[i] = 255 - d[i]; d[i+1] = 255 - d[i+1]; d[i+2] = 255 - d[i+2]; }
    ctx.putImageData(img, 0, 0);
}

function applyCyber(ctx, w, h) {
    const img = ctx.getImageData(0, 0, w, h), d = img.data;
    for (let i = 0; i < d.length; i += 4) {
        const g = d[i] * 0.299 + d[i+1] * 0.587 + d[i+2] * 0.114;
        const n = g / 255;
        // Cyan â†’ magenta â†’ yellow ramp
        d[i] = Math.round(n < 0.5 ? n*2*80 : 80 + (n-0.5)*2*175);
        d[i+1] = Math.round(n < 0.33 ? 200*n*3 : n < 0.66 ? 200 - (n-0.33)*3*150 : 50 + (n-0.66)*3*205);
        d[i+2] = Math.round(n < 0.5 ? 255 - n*2*155 : 100 - (n-0.5)*2*100);
    }
    ctx.putImageData(img, 0, 0);
}

// â”€â”€ Render filter overlay in real-time â”€â”€
let filterAnimId = null;
function filterLoop() {
    const f = filters[filterIdx];
    if (f.fn && video.readyState >= 2) {
        const vw = video.videoWidth || 480, vh = video.videoHeight || 360;
        if (filterCanvas.width !== vw) { filterCanvas.width = vw; filterCanvas.height = vh; }
        fCtx.drawImage(video, 0, 0, vw, vh);
        f.fn(fCtx, vw, vh);
    }
    filterAnimId = requestAnimationFrame(filterLoop);
}
filterLoop();

// â”€â”€ Stream / WebSocket â”€â”€
function setStatus(state, text) {
    statusPill.className = 'status-pill ' + state;
    statusPill.textContent = text || state;
}

function toggleStream() {
    if (ws) stopStream(); else startStream();
}

function startStream() {
    let host = hostInput.value.trim();
    if (!host) { hostInput.focus(); return; }
    if (!host.includes(':')) host += ':9876';
    if (!host.startsWith('ws://')) host = 'ws://' + host;

    setStatus('connecting', 'connectingâ€¦');
    ws = new WebSocket(host);
    ws.onopen = () => {
        setStatus('live', 'streaming');
        badge.className = 'badge live';
        badge.textContent = `${facingMode === 'user' ? 'front' : 'back'} â†’ ${hostInput.value}`;
        connectBtn.textContent = 'Stop';
        connectBtn.className = 'send-btn stop';
        frameCount = 0;
        lastFpsTime = performance.now();
        lastFpsCount = 0;
        sendLoop();
    };
    ws.onclose = () => stopStream();
    ws.onerror = () => { setStatus('error', 'error'); stopStream(); };
    ws.onmessage = (evt) => {
        // Handle incoming messages from terminal (chat, commands)
        try {
            const msg = JSON.parse(evt.data);
            if (msg.type === 'chat') showIncomingChat(msg.text, msg.from || 'terminal');
            if (msg.type === 'cmd') handleRemoteCmd(msg.cmd);
        } catch(e) {}
    };
}

function stopStream() {
    if (animId) { clearTimeout(animId); animId = null; }
    if (ws) { try { ws.close(); } catch(e) {} }
    ws = null;
    setStatus('off', 'disconnected');
    badge.className = 'badge';
    badge.textContent = facingMode === 'user' ? 'front' : 'back';
    connectBtn.textContent = 'Send';
    connectBtn.className = 'send-btn';
}

function sendLoop() {
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    const q = qualities[qualityIdx];
    hiddenCanvas.width = q.w; hiddenCanvas.height = q.h;
    hCtx.drawImage(video, 0, 0, q.w, q.h);

    // Apply filter to outgoing frame
    if (filters[filterIdx].fn) filters[filterIdx].fn(hCtx, q.w, q.h);

    const dataUrl = hiddenCanvas.toDataURL('image/jpeg', quality);
    const b64 = dataUrl.split(',')[1];
    const sz = Math.round(b64.length * 0.75);

    const packet = JSON.stringify({
        type: 'frame',
        v: '4.0.0',
        src: `phone:${facingMode === 'user' ? 'front' : 'back'}`,
        filter: filters[filterIdx].name,
        w: q.w, h: q.h, sz, t: Date.now() / 1000,
    }) + '\n' + b64;

    try { ws.send(packet); } catch(e) { stopStream(); return; }

    frameCount++;
    document.getElementById('s-frames').textContent = frameCount;
    document.getElementById('s-size').textContent = (sz / 1024).toFixed(1) + ' KB';

    const now = performance.now();
    if (now - lastFpsTime > 1000) {
        const fps = Math.round((frameCount - lastFpsCount) / ((now - lastFpsTime) / 1000));
        document.getElementById('s-fps').textContent = fps;
        document.getElementById('s-lat').textContent = Math.round(1000 / Math.max(1, fps)) + ' ms';
        lastFpsCount = frameCount;
        lastFpsTime = now;
    }

    animId = setTimeout(() => requestAnimationFrame(sendLoop), 50);
}

// â”€â”€ Chat â”€â”€
function sendChat() {
    const text = chatInput.value.trim();
    if (!text) return;
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'chat', text, from: 'phone', t: Date.now() }));
    }
    // Also broadcast for hexterm integration
    try {
        const bc = new BroadcastChannel('hexterm');
        bc.postMessage({ type: 'chat', text, from: 'hexcast-send' });
        bc.close();
    } catch(e) {}
    chatInput.value = '';
}

chatInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') { e.preventDefault(); sendChat(); }
});

function showIncomingChat(text, from) {
    // Brief visual indication in badge
    const old = badge.textContent;
    badge.textContent = `ğŸ’¬ ${from}: ${text}`;
    setTimeout(() => { badge.textContent = old; }, 3000);
}

function handleRemoteCmd(cmd) {
    if (cmd === 'swap') swapCamera();
    else if (cmd === 'snapshot') takeSnapshot();
    else if (cmd === 'filter') cycleFilter();
    else if (cmd === 'torch') toggleTorch();
    else if (cmd.startsWith('quality:')) {
        const idx = qualities.findIndex(q => q.label === cmd.split(':')[1]);
        if (idx >= 0) { qualityIdx = idx; quality = qualities[qualityIdx].q; document.getElementById('btn-quality').textContent = 'â—‰ ' + qualities[qualityIdx].label; if (stream) startCamera(); }
    }
}

// â”€â”€ BroadcastChannel for hexterm pairing â”€â”€
try {
    const bc = new BroadcastChannel('hexterm');
    bc.onmessage = e => {
        const d = e.data;
        if (d.type === 'cmd' && d.target === 'hexcast-send') handleRemoteCmd(d.cmd);
        if (d.type === 'chat' && d.from !== 'hexcast-send') showIncomingChat(d.text, d.from || 'terminal');
    };
} catch(e) {}

// â”€â”€ PWA Service Worker â”€â”€
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js').catch(() => {});
}

// Start camera on load
startCamera();

console.log('âš› hexcast send v4.0 â€” camera â†’ terminal streaming');
console.log('{+1, 1, -1, +0, 0, -0, +n, n, -n}');
</script>
</body>
</html>
